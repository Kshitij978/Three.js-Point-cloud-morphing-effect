{"version":3,"file":"index-DKPlbzSG.js","sources":["../../node_modules/three/examples/jsm/loaders/OBJLoader.js","../../node_modules/three/examples/jsm/math/MeshSurfaceSampler.js","../../src/main.ts"],"sourcesContent":["import {\n\tBufferGeometry,\n\tFileLoader,\n\tFloat32BufferAttribute,\n\tGroup,\n\tLineBasicMaterial,\n\tLineSegments,\n\tLoader,\n\tMaterial,\n\tMesh,\n\tMeshPhongMaterial,\n\tPoints,\n\tPointsMaterial,\n\tVector3,\n\tColor\n} from 'three';\n\n// o object_name | g group_name\nconst _object_pattern = /^[og]\\s*(.+)?/;\n// mtllib file_reference\nconst _material_library_pattern = /^mtllib /;\n// usemtl material_name\nconst _material_use_pattern = /^usemtl /;\n// usemap map_name\nconst _map_use_pattern = /^usemap /;\nconst _face_vertex_data_separator_pattern = /\\s+/;\n\nconst _vA = new Vector3();\nconst _vB = new Vector3();\nconst _vC = new Vector3();\n\nconst _ab = new Vector3();\nconst _cb = new Vector3();\n\nconst _color = new Color();\n\nfunction ParserState() {\n\n\tconst state = {\n\t\tobjects: [],\n\t\tobject: {},\n\n\t\tvertices: [],\n\t\tnormals: [],\n\t\tcolors: [],\n\t\tuvs: [],\n\n\t\tmaterials: {},\n\t\tmaterialLibraries: [],\n\n\t\tstartObject: function ( name, fromDeclaration ) {\n\n\t\t\t// If the current object (initial from reset) is not from a g/o declaration in the parsed\n\t\t\t// file. We need to use it for the first parsed g/o to keep things in sync.\n\t\t\tif ( this.object && this.object.fromDeclaration === false ) {\n\n\t\t\t\tthis.object.name = name;\n\t\t\t\tthis.object.fromDeclaration = ( fromDeclaration !== false );\n\t\t\t\treturn;\n\n\t\t\t}\n\n\t\t\tconst previousMaterial = ( this.object && typeof this.object.currentMaterial === 'function' ? this.object.currentMaterial() : undefined );\n\n\t\t\tif ( this.object && typeof this.object._finalize === 'function' ) {\n\n\t\t\t\tthis.object._finalize( true );\n\n\t\t\t}\n\n\t\t\tthis.object = {\n\t\t\t\tname: name || '',\n\t\t\t\tfromDeclaration: ( fromDeclaration !== false ),\n\n\t\t\t\tgeometry: {\n\t\t\t\t\tvertices: [],\n\t\t\t\t\tnormals: [],\n\t\t\t\t\tcolors: [],\n\t\t\t\t\tuvs: [],\n\t\t\t\t\thasUVIndices: false\n\t\t\t\t},\n\t\t\t\tmaterials: [],\n\t\t\t\tsmooth: true,\n\n\t\t\t\tstartMaterial: function ( name, libraries ) {\n\n\t\t\t\t\tconst previous = this._finalize( false );\n\n\t\t\t\t\t// New usemtl declaration overwrites an inherited material, except if faces were declared\n\t\t\t\t\t// after the material, then it must be preserved for proper MultiMaterial continuation.\n\t\t\t\t\tif ( previous && ( previous.inherited || previous.groupCount <= 0 ) ) {\n\n\t\t\t\t\t\tthis.materials.splice( previous.index, 1 );\n\n\t\t\t\t\t}\n\n\t\t\t\t\tconst material = {\n\t\t\t\t\t\tindex: this.materials.length,\n\t\t\t\t\t\tname: name || '',\n\t\t\t\t\t\tmtllib: ( Array.isArray( libraries ) && libraries.length > 0 ? libraries[ libraries.length - 1 ] : '' ),\n\t\t\t\t\t\tsmooth: ( previous !== undefined ? previous.smooth : this.smooth ),\n\t\t\t\t\t\tgroupStart: ( previous !== undefined ? previous.groupEnd : 0 ),\n\t\t\t\t\t\tgroupEnd: - 1,\n\t\t\t\t\t\tgroupCount: - 1,\n\t\t\t\t\t\tinherited: false,\n\n\t\t\t\t\t\tclone: function ( index ) {\n\n\t\t\t\t\t\t\tconst cloned = {\n\t\t\t\t\t\t\t\tindex: ( typeof index === 'number' ? index : this.index ),\n\t\t\t\t\t\t\t\tname: this.name,\n\t\t\t\t\t\t\t\tmtllib: this.mtllib,\n\t\t\t\t\t\t\t\tsmooth: this.smooth,\n\t\t\t\t\t\t\t\tgroupStart: 0,\n\t\t\t\t\t\t\t\tgroupEnd: - 1,\n\t\t\t\t\t\t\t\tgroupCount: - 1,\n\t\t\t\t\t\t\t\tinherited: false\n\t\t\t\t\t\t\t};\n\t\t\t\t\t\t\tcloned.clone = this.clone.bind( cloned );\n\t\t\t\t\t\t\treturn cloned;\n\n\t\t\t\t\t\t}\n\t\t\t\t\t};\n\n\t\t\t\t\tthis.materials.push( material );\n\n\t\t\t\t\treturn material;\n\n\t\t\t\t},\n\n\t\t\t\tcurrentMaterial: function () {\n\n\t\t\t\t\tif ( this.materials.length > 0 ) {\n\n\t\t\t\t\t\treturn this.materials[ this.materials.length - 1 ];\n\n\t\t\t\t\t}\n\n\t\t\t\t\treturn undefined;\n\n\t\t\t\t},\n\n\t\t\t\t_finalize: function ( end ) {\n\n\t\t\t\t\tconst lastMultiMaterial = this.currentMaterial();\n\t\t\t\t\tif ( lastMultiMaterial && lastMultiMaterial.groupEnd === - 1 ) {\n\n\t\t\t\t\t\tlastMultiMaterial.groupEnd = this.geometry.vertices.length / 3;\n\t\t\t\t\t\tlastMultiMaterial.groupCount = lastMultiMaterial.groupEnd - lastMultiMaterial.groupStart;\n\t\t\t\t\t\tlastMultiMaterial.inherited = false;\n\n\t\t\t\t\t}\n\n\t\t\t\t\t// Ignore objects tail materials if no face declarations followed them before a new o/g started.\n\t\t\t\t\tif ( end && this.materials.length > 1 ) {\n\n\t\t\t\t\t\tfor ( let mi = this.materials.length - 1; mi >= 0; mi -- ) {\n\n\t\t\t\t\t\t\tif ( this.materials[ mi ].groupCount <= 0 ) {\n\n\t\t\t\t\t\t\t\tthis.materials.splice( mi, 1 );\n\n\t\t\t\t\t\t\t}\n\n\t\t\t\t\t\t}\n\n\t\t\t\t\t}\n\n\t\t\t\t\t// Guarantee at least one empty material, this makes the creation later more straight forward.\n\t\t\t\t\tif ( end && this.materials.length === 0 ) {\n\n\t\t\t\t\t\tthis.materials.push( {\n\t\t\t\t\t\t\tname: '',\n\t\t\t\t\t\t\tsmooth: this.smooth\n\t\t\t\t\t\t} );\n\n\t\t\t\t\t}\n\n\t\t\t\t\treturn lastMultiMaterial;\n\n\t\t\t\t}\n\t\t\t};\n\n\t\t\t// Inherit previous objects material.\n\t\t\t// Spec tells us that a declared material must be set to all objects until a new material is declared.\n\t\t\t// If a usemtl declaration is encountered while this new object is being parsed, it will\n\t\t\t// overwrite the inherited material. Exception being that there was already face declarations\n\t\t\t// to the inherited material, then it will be preserved for proper MultiMaterial continuation.\n\n\t\t\tif ( previousMaterial && previousMaterial.name && typeof previousMaterial.clone === 'function' ) {\n\n\t\t\t\tconst declared = previousMaterial.clone( 0 );\n\t\t\t\tdeclared.inherited = true;\n\t\t\t\tthis.object.materials.push( declared );\n\n\t\t\t}\n\n\t\t\tthis.objects.push( this.object );\n\n\t\t},\n\n\t\tfinalize: function () {\n\n\t\t\tif ( this.object && typeof this.object._finalize === 'function' ) {\n\n\t\t\t\tthis.object._finalize( true );\n\n\t\t\t}\n\n\t\t},\n\n\t\tparseVertexIndex: function ( value, len ) {\n\n\t\t\tconst index = parseInt( value, 10 );\n\t\t\treturn ( index >= 0 ? index - 1 : index + len / 3 ) * 3;\n\n\t\t},\n\n\t\tparseNormalIndex: function ( value, len ) {\n\n\t\t\tconst index = parseInt( value, 10 );\n\t\t\treturn ( index >= 0 ? index - 1 : index + len / 3 ) * 3;\n\n\t\t},\n\n\t\tparseUVIndex: function ( value, len ) {\n\n\t\t\tconst index = parseInt( value, 10 );\n\t\t\treturn ( index >= 0 ? index - 1 : index + len / 2 ) * 2;\n\n\t\t},\n\n\t\taddVertex: function ( a, b, c ) {\n\n\t\t\tconst src = this.vertices;\n\t\t\tconst dst = this.object.geometry.vertices;\n\n\t\t\tdst.push( src[ a + 0 ], src[ a + 1 ], src[ a + 2 ] );\n\t\t\tdst.push( src[ b + 0 ], src[ b + 1 ], src[ b + 2 ] );\n\t\t\tdst.push( src[ c + 0 ], src[ c + 1 ], src[ c + 2 ] );\n\n\t\t},\n\n\t\taddVertexPoint: function ( a ) {\n\n\t\t\tconst src = this.vertices;\n\t\t\tconst dst = this.object.geometry.vertices;\n\n\t\t\tdst.push( src[ a + 0 ], src[ a + 1 ], src[ a + 2 ] );\n\n\t\t},\n\n\t\taddVertexLine: function ( a ) {\n\n\t\t\tconst src = this.vertices;\n\t\t\tconst dst = this.object.geometry.vertices;\n\n\t\t\tdst.push( src[ a + 0 ], src[ a + 1 ], src[ a + 2 ] );\n\n\t\t},\n\n\t\taddNormal: function ( a, b, c ) {\n\n\t\t\tconst src = this.normals;\n\t\t\tconst dst = this.object.geometry.normals;\n\n\t\t\tdst.push( src[ a + 0 ], src[ a + 1 ], src[ a + 2 ] );\n\t\t\tdst.push( src[ b + 0 ], src[ b + 1 ], src[ b + 2 ] );\n\t\t\tdst.push( src[ c + 0 ], src[ c + 1 ], src[ c + 2 ] );\n\n\t\t},\n\n\t\taddFaceNormal: function ( a, b, c ) {\n\n\t\t\tconst src = this.vertices;\n\t\t\tconst dst = this.object.geometry.normals;\n\n\t\t\t_vA.fromArray( src, a );\n\t\t\t_vB.fromArray( src, b );\n\t\t\t_vC.fromArray( src, c );\n\n\t\t\t_cb.subVectors( _vC, _vB );\n\t\t\t_ab.subVectors( _vA, _vB );\n\t\t\t_cb.cross( _ab );\n\n\t\t\t_cb.normalize();\n\n\t\t\tdst.push( _cb.x, _cb.y, _cb.z );\n\t\t\tdst.push( _cb.x, _cb.y, _cb.z );\n\t\t\tdst.push( _cb.x, _cb.y, _cb.z );\n\n\t\t},\n\n\t\taddColor: function ( a, b, c ) {\n\n\t\t\tconst src = this.colors;\n\t\t\tconst dst = this.object.geometry.colors;\n\n\t\t\tif ( src[ a ] !== undefined ) dst.push( src[ a + 0 ], src[ a + 1 ], src[ a + 2 ] );\n\t\t\tif ( src[ b ] !== undefined ) dst.push( src[ b + 0 ], src[ b + 1 ], src[ b + 2 ] );\n\t\t\tif ( src[ c ] !== undefined ) dst.push( src[ c + 0 ], src[ c + 1 ], src[ c + 2 ] );\n\n\t\t},\n\n\t\taddUV: function ( a, b, c ) {\n\n\t\t\tconst src = this.uvs;\n\t\t\tconst dst = this.object.geometry.uvs;\n\n\t\t\tdst.push( src[ a + 0 ], src[ a + 1 ] );\n\t\t\tdst.push( src[ b + 0 ], src[ b + 1 ] );\n\t\t\tdst.push( src[ c + 0 ], src[ c + 1 ] );\n\n\t\t},\n\n\t\taddDefaultUV: function () {\n\n\t\t\tconst dst = this.object.geometry.uvs;\n\n\t\t\tdst.push( 0, 0 );\n\t\t\tdst.push( 0, 0 );\n\t\t\tdst.push( 0, 0 );\n\n\t\t},\n\n\t\taddUVLine: function ( a ) {\n\n\t\t\tconst src = this.uvs;\n\t\t\tconst dst = this.object.geometry.uvs;\n\n\t\t\tdst.push( src[ a + 0 ], src[ a + 1 ] );\n\n\t\t},\n\n\t\taddFace: function ( a, b, c, ua, ub, uc, na, nb, nc ) {\n\n\t\t\tconst vLen = this.vertices.length;\n\n\t\t\tlet ia = this.parseVertexIndex( a, vLen );\n\t\t\tlet ib = this.parseVertexIndex( b, vLen );\n\t\t\tlet ic = this.parseVertexIndex( c, vLen );\n\n\t\t\tthis.addVertex( ia, ib, ic );\n\t\t\tthis.addColor( ia, ib, ic );\n\n\t\t\t// normals\n\n\t\t\tif ( na !== undefined && na !== '' ) {\n\n\t\t\t\tconst nLen = this.normals.length;\n\n\t\t\t\tia = this.parseNormalIndex( na, nLen );\n\t\t\t\tib = this.parseNormalIndex( nb, nLen );\n\t\t\t\tic = this.parseNormalIndex( nc, nLen );\n\n\t\t\t\tthis.addNormal( ia, ib, ic );\n\n\t\t\t} else {\n\n\t\t\t\tthis.addFaceNormal( ia, ib, ic );\n\n\t\t\t}\n\n\t\t\t// uvs\n\n\t\t\tif ( ua !== undefined && ua !== '' ) {\n\n\t\t\t\tconst uvLen = this.uvs.length;\n\n\t\t\t\tia = this.parseUVIndex( ua, uvLen );\n\t\t\t\tib = this.parseUVIndex( ub, uvLen );\n\t\t\t\tic = this.parseUVIndex( uc, uvLen );\n\n\t\t\t\tthis.addUV( ia, ib, ic );\n\n\t\t\t\tthis.object.geometry.hasUVIndices = true;\n\n\t\t\t} else {\n\n\t\t\t\t// add placeholder values (for inconsistent face definitions)\n\n\t\t\t\tthis.addDefaultUV();\n\n\t\t\t}\n\n\t\t},\n\n\t\taddPointGeometry: function ( vertices ) {\n\n\t\t\tthis.object.geometry.type = 'Points';\n\n\t\t\tconst vLen = this.vertices.length;\n\n\t\t\tfor ( let vi = 0, l = vertices.length; vi < l; vi ++ ) {\n\n\t\t\t\tconst index = this.parseVertexIndex( vertices[ vi ], vLen );\n\n\t\t\t\tthis.addVertexPoint( index );\n\t\t\t\tthis.addColor( index );\n\n\t\t\t}\n\n\t\t},\n\n\t\taddLineGeometry: function ( vertices, uvs ) {\n\n\t\t\tthis.object.geometry.type = 'Line';\n\n\t\t\tconst vLen = this.vertices.length;\n\t\t\tconst uvLen = this.uvs.length;\n\n\t\t\tfor ( let vi = 0, l = vertices.length; vi < l; vi ++ ) {\n\n\t\t\t\tthis.addVertexLine( this.parseVertexIndex( vertices[ vi ], vLen ) );\n\n\t\t\t}\n\n\t\t\tfor ( let uvi = 0, l = uvs.length; uvi < l; uvi ++ ) {\n\n\t\t\t\tthis.addUVLine( this.parseUVIndex( uvs[ uvi ], uvLen ) );\n\n\t\t\t}\n\n\t\t}\n\n\t};\n\n\tstate.startObject( '', false );\n\n\treturn state;\n\n}\n\n//\n\nclass OBJLoader extends Loader {\n\n\tconstructor( manager ) {\n\n\t\tsuper( manager );\n\n\t\tthis.materials = null;\n\n\t}\n\n\tload( url, onLoad, onProgress, onError ) {\n\n\t\tconst scope = this;\n\n\t\tconst loader = new FileLoader( this.manager );\n\t\tloader.setPath( this.path );\n\t\tloader.setRequestHeader( this.requestHeader );\n\t\tloader.setWithCredentials( this.withCredentials );\n\t\tloader.load( url, function ( text ) {\n\n\t\t\ttry {\n\n\t\t\t\tonLoad( scope.parse( text ) );\n\n\t\t\t} catch ( e ) {\n\n\t\t\t\tif ( onError ) {\n\n\t\t\t\t\tonError( e );\n\n\t\t\t\t} else {\n\n\t\t\t\t\tconsole.error( e );\n\n\t\t\t\t}\n\n\t\t\t\tscope.manager.itemError( url );\n\n\t\t\t}\n\n\t\t}, onProgress, onError );\n\n\t}\n\n\tsetMaterials( materials ) {\n\n\t\tthis.materials = materials;\n\n\t\treturn this;\n\n\t}\n\n\tparse( text ) {\n\n\t\tconst state = new ParserState();\n\n\t\tif ( text.indexOf( '\\r\\n' ) !== - 1 ) {\n\n\t\t\t// This is faster than String.split with regex that splits on both\n\t\t\ttext = text.replace( /\\r\\n/g, '\\n' );\n\n\t\t}\n\n\t\tif ( text.indexOf( '\\\\\\n' ) !== - 1 ) {\n\n\t\t\t// join lines separated by a line continuation character (\\)\n\t\t\ttext = text.replace( /\\\\\\n/g, '' );\n\n\t\t}\n\n\t\tconst lines = text.split( '\\n' );\n\t\tlet result = [];\n\n\t\tfor ( let i = 0, l = lines.length; i < l; i ++ ) {\n\n\t\t\tconst line = lines[ i ].trimStart();\n\n\t\t\tif ( line.length === 0 ) continue;\n\n\t\t\tconst lineFirstChar = line.charAt( 0 );\n\n\t\t\t// @todo invoke passed in handler if any\n\t\t\tif ( lineFirstChar === '#' ) continue; // skip comments\n\n\t\t\tif ( lineFirstChar === 'v' ) {\n\n\t\t\t\tconst data = line.split( _face_vertex_data_separator_pattern );\n\n\t\t\t\tswitch ( data[ 0 ] ) {\n\n\t\t\t\t\tcase 'v':\n\t\t\t\t\t\tstate.vertices.push(\n\t\t\t\t\t\t\tparseFloat( data[ 1 ] ),\n\t\t\t\t\t\t\tparseFloat( data[ 2 ] ),\n\t\t\t\t\t\t\tparseFloat( data[ 3 ] )\n\t\t\t\t\t\t);\n\t\t\t\t\t\tif ( data.length >= 7 ) {\n\n\t\t\t\t\t\t\t_color.setRGB(\n\t\t\t\t\t\t\t\tparseFloat( data[ 4 ] ),\n\t\t\t\t\t\t\t\tparseFloat( data[ 5 ] ),\n\t\t\t\t\t\t\t\tparseFloat( data[ 6 ] )\n\t\t\t\t\t\t\t).convertSRGBToLinear();\n\n\t\t\t\t\t\t\tstate.colors.push( _color.r, _color.g, _color.b );\n\n\t\t\t\t\t\t} else {\n\n\t\t\t\t\t\t\t// if no colors are defined, add placeholders so color and vertex indices match\n\n\t\t\t\t\t\t\tstate.colors.push( undefined, undefined, undefined );\n\n\t\t\t\t\t\t}\n\n\t\t\t\t\t\tbreak;\n\t\t\t\t\tcase 'vn':\n\t\t\t\t\t\tstate.normals.push(\n\t\t\t\t\t\t\tparseFloat( data[ 1 ] ),\n\t\t\t\t\t\t\tparseFloat( data[ 2 ] ),\n\t\t\t\t\t\t\tparseFloat( data[ 3 ] )\n\t\t\t\t\t\t);\n\t\t\t\t\t\tbreak;\n\t\t\t\t\tcase 'vt':\n\t\t\t\t\t\tstate.uvs.push(\n\t\t\t\t\t\t\tparseFloat( data[ 1 ] ),\n\t\t\t\t\t\t\tparseFloat( data[ 2 ] )\n\t\t\t\t\t\t);\n\t\t\t\t\t\tbreak;\n\n\t\t\t\t}\n\n\t\t\t} else if ( lineFirstChar === 'f' ) {\n\n\t\t\t\tconst lineData = line.slice( 1 ).trim();\n\t\t\t\tconst vertexData = lineData.split( _face_vertex_data_separator_pattern );\n\t\t\t\tconst faceVertices = [];\n\n\t\t\t\t// Parse the face vertex data into an easy to work with format\n\n\t\t\t\tfor ( let j = 0, jl = vertexData.length; j < jl; j ++ ) {\n\n\t\t\t\t\tconst vertex = vertexData[ j ];\n\n\t\t\t\t\tif ( vertex.length > 0 ) {\n\n\t\t\t\t\t\tconst vertexParts = vertex.split( '/' );\n\t\t\t\t\t\tfaceVertices.push( vertexParts );\n\n\t\t\t\t\t}\n\n\t\t\t\t}\n\n\t\t\t\t// Draw an edge between the first vertex and all subsequent vertices to form an n-gon\n\n\t\t\t\tconst v1 = faceVertices[ 0 ];\n\n\t\t\t\tfor ( let j = 1, jl = faceVertices.length - 1; j < jl; j ++ ) {\n\n\t\t\t\t\tconst v2 = faceVertices[ j ];\n\t\t\t\t\tconst v3 = faceVertices[ j + 1 ];\n\n\t\t\t\t\tstate.addFace(\n\t\t\t\t\t\tv1[ 0 ], v2[ 0 ], v3[ 0 ],\n\t\t\t\t\t\tv1[ 1 ], v2[ 1 ], v3[ 1 ],\n\t\t\t\t\t\tv1[ 2 ], v2[ 2 ], v3[ 2 ]\n\t\t\t\t\t);\n\n\t\t\t\t}\n\n\t\t\t} else if ( lineFirstChar === 'l' ) {\n\n\t\t\t\tconst lineParts = line.substring( 1 ).trim().split( ' ' );\n\t\t\t\tlet lineVertices = [];\n\t\t\t\tconst lineUVs = [];\n\n\t\t\t\tif ( line.indexOf( '/' ) === - 1 ) {\n\n\t\t\t\t\tlineVertices = lineParts;\n\n\t\t\t\t} else {\n\n\t\t\t\t\tfor ( let li = 0, llen = lineParts.length; li < llen; li ++ ) {\n\n\t\t\t\t\t\tconst parts = lineParts[ li ].split( '/' );\n\n\t\t\t\t\t\tif ( parts[ 0 ] !== '' ) lineVertices.push( parts[ 0 ] );\n\t\t\t\t\t\tif ( parts[ 1 ] !== '' ) lineUVs.push( parts[ 1 ] );\n\n\t\t\t\t\t}\n\n\t\t\t\t}\n\n\t\t\t\tstate.addLineGeometry( lineVertices, lineUVs );\n\n\t\t\t} else if ( lineFirstChar === 'p' ) {\n\n\t\t\t\tconst lineData = line.slice( 1 ).trim();\n\t\t\t\tconst pointData = lineData.split( ' ' );\n\n\t\t\t\tstate.addPointGeometry( pointData );\n\n\t\t\t} else if ( ( result = _object_pattern.exec( line ) ) !== null ) {\n\n\t\t\t\t// o object_name\n\t\t\t\t// or\n\t\t\t\t// g group_name\n\n\t\t\t\t// WORKAROUND: https://bugs.chromium.org/p/v8/issues/detail?id=2869\n\t\t\t\t// let name = result[ 0 ].slice( 1 ).trim();\n\t\t\t\tconst name = ( ' ' + result[ 0 ].slice( 1 ).trim() ).slice( 1 );\n\n\t\t\t\tstate.startObject( name );\n\n\t\t\t} else if ( _material_use_pattern.test( line ) ) {\n\n\t\t\t\t// material\n\n\t\t\t\tstate.object.startMaterial( line.substring( 7 ).trim(), state.materialLibraries );\n\n\t\t\t} else if ( _material_library_pattern.test( line ) ) {\n\n\t\t\t\t// mtl file\n\n\t\t\t\tstate.materialLibraries.push( line.substring( 7 ).trim() );\n\n\t\t\t} else if ( _map_use_pattern.test( line ) ) {\n\n\t\t\t\t// the line is parsed but ignored since the loader assumes textures are defined MTL files\n\t\t\t\t// (according to https://www.okino.com/conv/imp_wave.htm, 'usemap' is the old-style Wavefront texture reference method)\n\n\t\t\t\tconsole.warn( 'THREE.OBJLoader: Rendering identifier \"usemap\" not supported. Textures must be defined in MTL files.' );\n\n\t\t\t} else if ( lineFirstChar === 's' ) {\n\n\t\t\t\tresult = line.split( ' ' );\n\n\t\t\t\t// smooth shading\n\n\t\t\t\t// @todo Handle files that have varying smooth values for a set of faces inside one geometry,\n\t\t\t\t// but does not define a usemtl for each face set.\n\t\t\t\t// This should be detected and a dummy material created (later MultiMaterial and geometry groups).\n\t\t\t\t// This requires some care to not create extra material on each smooth value for \"normal\" obj files.\n\t\t\t\t// where explicit usemtl defines geometry groups.\n\t\t\t\t// Example asset: examples/models/obj/cerberus/Cerberus.obj\n\n\t\t\t\t/*\n\t\t\t\t\t * http://paulbourke.net/dataformats/obj/\n\t\t\t\t\t *\n\t\t\t\t\t * From chapter \"Grouping\" Syntax explanation \"s group_number\":\n\t\t\t\t\t * \"group_number is the smoothing group number. To turn off smoothing groups, use a value of 0 or off.\n\t\t\t\t\t * Polygonal elements use group numbers to put elements in different smoothing groups. For free-form\n\t\t\t\t\t * surfaces, smoothing groups are either turned on or off; there is no difference between values greater\n\t\t\t\t\t * than 0.\"\n\t\t\t\t\t */\n\t\t\t\tif ( result.length > 1 ) {\n\n\t\t\t\t\tconst value = result[ 1 ].trim().toLowerCase();\n\t\t\t\t\tstate.object.smooth = ( value !== '0' && value !== 'off' );\n\n\t\t\t\t} else {\n\n\t\t\t\t\t// ZBrush can produce \"s\" lines #11707\n\t\t\t\t\tstate.object.smooth = true;\n\n\t\t\t\t}\n\n\t\t\t\tconst material = state.object.currentMaterial();\n\t\t\t\tif ( material ) material.smooth = state.object.smooth;\n\n\t\t\t} else {\n\n\t\t\t\t// Handle null terminated files without exception\n\t\t\t\tif ( line === '\\0' ) continue;\n\n\t\t\t\tconsole.warn( 'THREE.OBJLoader: Unexpected line: \"' + line + '\"' );\n\n\t\t\t}\n\n\t\t}\n\n\t\tstate.finalize();\n\n\t\tconst container = new Group();\n\t\tcontainer.materialLibraries = [].concat( state.materialLibraries );\n\n\t\tconst hasPrimitives = ! ( state.objects.length === 1 && state.objects[ 0 ].geometry.vertices.length === 0 );\n\n\t\tif ( hasPrimitives === true ) {\n\n\t\t\tfor ( let i = 0, l = state.objects.length; i < l; i ++ ) {\n\n\t\t\t\tconst object = state.objects[ i ];\n\t\t\t\tconst geometry = object.geometry;\n\t\t\t\tconst materials = object.materials;\n\t\t\t\tconst isLine = ( geometry.type === 'Line' );\n\t\t\t\tconst isPoints = ( geometry.type === 'Points' );\n\t\t\t\tlet hasVertexColors = false;\n\n\t\t\t\t// Skip o/g line declarations that did not follow with any faces\n\t\t\t\tif ( geometry.vertices.length === 0 ) continue;\n\n\t\t\t\tconst buffergeometry = new BufferGeometry();\n\n\t\t\t\tbuffergeometry.setAttribute( 'position', new Float32BufferAttribute( geometry.vertices, 3 ) );\n\n\t\t\t\tif ( geometry.normals.length > 0 ) {\n\n\t\t\t\t\tbuffergeometry.setAttribute( 'normal', new Float32BufferAttribute( geometry.normals, 3 ) );\n\n\t\t\t\t}\n\n\t\t\t\tif ( geometry.colors.length > 0 ) {\n\n\t\t\t\t\thasVertexColors = true;\n\t\t\t\t\tbuffergeometry.setAttribute( 'color', new Float32BufferAttribute( geometry.colors, 3 ) );\n\n\t\t\t\t}\n\n\t\t\t\tif ( geometry.hasUVIndices === true ) {\n\n\t\t\t\t\tbuffergeometry.setAttribute( 'uv', new Float32BufferAttribute( geometry.uvs, 2 ) );\n\n\t\t\t\t}\n\n\t\t\t\t// Create materials\n\n\t\t\t\tconst createdMaterials = [];\n\n\t\t\t\tfor ( let mi = 0, miLen = materials.length; mi < miLen; mi ++ ) {\n\n\t\t\t\t\tconst sourceMaterial = materials[ mi ];\n\t\t\t\t\tconst materialHash = sourceMaterial.name + '_' + sourceMaterial.smooth + '_' + hasVertexColors;\n\t\t\t\t\tlet material = state.materials[ materialHash ];\n\n\t\t\t\t\tif ( this.materials !== null ) {\n\n\t\t\t\t\t\tmaterial = this.materials.create( sourceMaterial.name );\n\n\t\t\t\t\t\t// mtl etc. loaders probably can't create line materials correctly, copy properties to a line material.\n\t\t\t\t\t\tif ( isLine && material && ! ( material instanceof LineBasicMaterial ) ) {\n\n\t\t\t\t\t\t\tconst materialLine = new LineBasicMaterial();\n\t\t\t\t\t\t\tMaterial.prototype.copy.call( materialLine, material );\n\t\t\t\t\t\t\tmaterialLine.color.copy( material.color );\n\t\t\t\t\t\t\tmaterial = materialLine;\n\n\t\t\t\t\t\t} else if ( isPoints && material && ! ( material instanceof PointsMaterial ) ) {\n\n\t\t\t\t\t\t\tconst materialPoints = new PointsMaterial( { size: 10, sizeAttenuation: false } );\n\t\t\t\t\t\t\tMaterial.prototype.copy.call( materialPoints, material );\n\t\t\t\t\t\t\tmaterialPoints.color.copy( material.color );\n\t\t\t\t\t\t\tmaterialPoints.map = material.map;\n\t\t\t\t\t\t\tmaterial = materialPoints;\n\n\t\t\t\t\t\t}\n\n\t\t\t\t\t}\n\n\t\t\t\t\tif ( material === undefined ) {\n\n\t\t\t\t\t\tif ( isLine ) {\n\n\t\t\t\t\t\t\tmaterial = new LineBasicMaterial();\n\n\t\t\t\t\t\t} else if ( isPoints ) {\n\n\t\t\t\t\t\t\tmaterial = new PointsMaterial( { size: 1, sizeAttenuation: false } );\n\n\t\t\t\t\t\t} else {\n\n\t\t\t\t\t\t\tmaterial = new MeshPhongMaterial();\n\n\t\t\t\t\t\t}\n\n\t\t\t\t\t\tmaterial.name = sourceMaterial.name;\n\t\t\t\t\t\tmaterial.flatShading = sourceMaterial.smooth ? false : true;\n\t\t\t\t\t\tmaterial.vertexColors = hasVertexColors;\n\n\t\t\t\t\t\tstate.materials[ materialHash ] = material;\n\n\t\t\t\t\t}\n\n\t\t\t\t\tcreatedMaterials.push( material );\n\n\t\t\t\t}\n\n\t\t\t\t// Create mesh\n\n\t\t\t\tlet mesh;\n\n\t\t\t\tif ( createdMaterials.length > 1 ) {\n\n\t\t\t\t\tfor ( let mi = 0, miLen = materials.length; mi < miLen; mi ++ ) {\n\n\t\t\t\t\t\tconst sourceMaterial = materials[ mi ];\n\t\t\t\t\t\tbuffergeometry.addGroup( sourceMaterial.groupStart, sourceMaterial.groupCount, mi );\n\n\t\t\t\t\t}\n\n\t\t\t\t\tif ( isLine ) {\n\n\t\t\t\t\t\tmesh = new LineSegments( buffergeometry, createdMaterials );\n\n\t\t\t\t\t} else if ( isPoints ) {\n\n\t\t\t\t\t\tmesh = new Points( buffergeometry, createdMaterials );\n\n\t\t\t\t\t} else {\n\n\t\t\t\t\t\tmesh = new Mesh( buffergeometry, createdMaterials );\n\n\t\t\t\t\t}\n\n\t\t\t\t} else {\n\n\t\t\t\t\tif ( isLine ) {\n\n\t\t\t\t\t\tmesh = new LineSegments( buffergeometry, createdMaterials[ 0 ] );\n\n\t\t\t\t\t} else if ( isPoints ) {\n\n\t\t\t\t\t\tmesh = new Points( buffergeometry, createdMaterials[ 0 ] );\n\n\t\t\t\t\t} else {\n\n\t\t\t\t\t\tmesh = new Mesh( buffergeometry, createdMaterials[ 0 ] );\n\n\t\t\t\t\t}\n\n\t\t\t\t}\n\n\t\t\t\tmesh.name = object.name;\n\n\t\t\t\tcontainer.add( mesh );\n\n\t\t\t}\n\n\t\t} else {\n\n\t\t\t// if there is only the default parser state object with no geometry data, interpret data as point cloud\n\n\t\t\tif ( state.vertices.length > 0 ) {\n\n\t\t\t\tconst material = new PointsMaterial( { size: 1, sizeAttenuation: false } );\n\n\t\t\t\tconst buffergeometry = new BufferGeometry();\n\n\t\t\t\tbuffergeometry.setAttribute( 'position', new Float32BufferAttribute( state.vertices, 3 ) );\n\n\t\t\t\tif ( state.colors.length > 0 && state.colors[ 0 ] !== undefined ) {\n\n\t\t\t\t\tbuffergeometry.setAttribute( 'color', new Float32BufferAttribute( state.colors, 3 ) );\n\t\t\t\t\tmaterial.vertexColors = true;\n\n\t\t\t\t}\n\n\t\t\t\tconst points = new Points( buffergeometry, material );\n\t\t\t\tcontainer.add( points );\n\n\t\t\t}\n\n\t\t}\n\n\t\treturn container;\n\n\t}\n\n}\n\nexport { OBJLoader };\n","import {\n\tTriangle,\n\tVector2,\n\tVector3\n} from 'three';\n\n/**\n * Utility class for sampling weighted random points on the surface of a mesh.\n *\n * Building the sampler is a one-time O(n) operation. Once built, any number of\n * random samples may be selected in O(logn) time. Memory usage is O(n).\n *\n * References:\n * - http://www.joesfer.com/?p=84\n * - https://stackoverflow.com/a/4322940/1314762\n */\n\nconst _face = new Triangle();\nconst _color = new Vector3();\nconst _uva = new Vector2(), _uvb = new Vector2(), _uvc = new Vector2();\n\nclass MeshSurfaceSampler {\n\n\tconstructor( mesh ) {\n\n\t\tthis.geometry = mesh.geometry;\n\t\tthis.randomFunction = Math.random;\n\n\t\tthis.indexAttribute = this.geometry.index;\n\t\tthis.positionAttribute = this.geometry.getAttribute( 'position' );\n\t\tthis.normalAttribute = this.geometry.getAttribute( 'normal' );\n\t\tthis.colorAttribute = this.geometry.getAttribute( 'color' );\n\t\tthis.uvAttribute = this.geometry.getAttribute( 'uv' );\n\t\tthis.weightAttribute = null;\n\n\t\tthis.distribution = null;\n\n\t}\n\n\tsetWeightAttribute( name ) {\n\n\t\tthis.weightAttribute = name ? this.geometry.getAttribute( name ) : null;\n\n\t\treturn this;\n\n\t}\n\n\tbuild() {\n\n\t\tconst indexAttribute = this.indexAttribute;\n\t\tconst positionAttribute = this.positionAttribute;\n\t\tconst weightAttribute = this.weightAttribute;\n\n\t\tconst totalFaces = indexAttribute ? ( indexAttribute.count / 3 ) : ( positionAttribute.count / 3 );\n\t\tconst faceWeights = new Float32Array( totalFaces );\n\n\t\t// Accumulate weights for each mesh face.\n\n\t\tfor ( let i = 0; i < totalFaces; i ++ ) {\n\n\t\t\tlet faceWeight = 1;\n\n\t\t\tlet i0 = 3 * i;\n\t\t\tlet i1 = 3 * i + 1;\n\t\t\tlet i2 = 3 * i + 2;\n\n\t\t\tif ( indexAttribute ) {\n\n\t\t\t\ti0 = indexAttribute.getX( i0 );\n\t\t\t\ti1 = indexAttribute.getX( i1 );\n\t\t\t\ti2 = indexAttribute.getX( i2 );\n\n\t\t\t}\n\n\t\t\tif ( weightAttribute ) {\n\n\t\t\t\tfaceWeight = weightAttribute.getX( i0 )\n\t\t\t\t\t+ weightAttribute.getX( i1 )\n\t\t\t\t\t+ weightAttribute.getX( i2 );\n\n\t\t\t}\n\n\t\t\t_face.a.fromBufferAttribute( positionAttribute, i0 );\n\t\t\t_face.b.fromBufferAttribute( positionAttribute, i1 );\n\t\t\t_face.c.fromBufferAttribute( positionAttribute, i2 );\n\t\t\tfaceWeight *= _face.getArea();\n\n\t\t\tfaceWeights[ i ] = faceWeight;\n\n\t\t}\n\n\t\t// Store cumulative total face weights in an array, where weight index\n\t\t// corresponds to face index.\n\n\t\tconst distribution = new Float32Array( totalFaces );\n\t\tlet cumulativeTotal = 0;\n\n\t\tfor ( let i = 0; i < totalFaces; i ++ ) {\n\n\t\t\tcumulativeTotal += faceWeights[ i ];\n\t\t\tdistribution[ i ] = cumulativeTotal;\n\n\t\t}\n\n\t\tthis.distribution = distribution;\n\t\treturn this;\n\n\t}\n\n\tsetRandomGenerator( randomFunction ) {\n\n\t\tthis.randomFunction = randomFunction;\n\t\treturn this;\n\n\t}\n\n\tsample( targetPosition, targetNormal, targetColor, targetUV ) {\n\n\t\tconst faceIndex = this.sampleFaceIndex();\n\t\treturn this.sampleFace( faceIndex, targetPosition, targetNormal, targetColor, targetUV );\n\n\t}\n\n\tsampleFaceIndex() {\n\n\t\tconst cumulativeTotal = this.distribution[ this.distribution.length - 1 ];\n\t\treturn this.binarySearch( this.randomFunction() * cumulativeTotal );\n\n\t}\n\n\tbinarySearch( x ) {\n\n\t\tconst dist = this.distribution;\n\t\tlet start = 0;\n\t\tlet end = dist.length - 1;\n\n\t\tlet index = - 1;\n\n\t\twhile ( start <= end ) {\n\n\t\t\tconst mid = Math.ceil( ( start + end ) / 2 );\n\n\t\t\tif ( mid === 0 || dist[ mid - 1 ] <= x && dist[ mid ] > x ) {\n\n\t\t\t\tindex = mid;\n\n\t\t\t\tbreak;\n\n\t\t\t} else if ( x < dist[ mid ] ) {\n\n\t\t\t\tend = mid - 1;\n\n\t\t\t} else {\n\n\t\t\t\tstart = mid + 1;\n\n\t\t\t}\n\n\t\t}\n\n\t\treturn index;\n\n\t}\n\n\tsampleFace( faceIndex, targetPosition, targetNormal, targetColor, targetUV ) {\n\n\t\tlet u = this.randomFunction();\n\t\tlet v = this.randomFunction();\n\n\t\tif ( u + v > 1 ) {\n\n\t\t\tu = 1 - u;\n\t\t\tv = 1 - v;\n\n\t\t}\n\n\t\t// get the vertex attribute indices\n\t\tconst indexAttribute = this.indexAttribute;\n\t\tlet i0 = faceIndex * 3;\n\t\tlet i1 = faceIndex * 3 + 1;\n\t\tlet i2 = faceIndex * 3 + 2;\n\t\tif ( indexAttribute ) {\n\n\t\t\ti0 = indexAttribute.getX( i0 );\n\t\t\ti1 = indexAttribute.getX( i1 );\n\t\t\ti2 = indexAttribute.getX( i2 );\n\n\t\t}\n\n\t\t_face.a.fromBufferAttribute( this.positionAttribute, i0 );\n\t\t_face.b.fromBufferAttribute( this.positionAttribute, i1 );\n\t\t_face.c.fromBufferAttribute( this.positionAttribute, i2 );\n\n\t\ttargetPosition\n\t\t\t.set( 0, 0, 0 )\n\t\t\t.addScaledVector( _face.a, u )\n\t\t\t.addScaledVector( _face.b, v )\n\t\t\t.addScaledVector( _face.c, 1 - ( u + v ) );\n\n\t\tif ( targetNormal !== undefined ) {\n\n\t\t\tif ( this.normalAttribute !== undefined ) {\n\n\t\t\t\t_face.a.fromBufferAttribute( this.normalAttribute, i0 );\n\t\t\t\t_face.b.fromBufferAttribute( this.normalAttribute, i1 );\n\t\t\t\t_face.c.fromBufferAttribute( this.normalAttribute, i2 );\n\t\t\t\ttargetNormal.set( 0, 0, 0 ).addScaledVector( _face.a, u ).addScaledVector( _face.b, v ).addScaledVector( _face.c, 1 - ( u + v ) ).normalize();\n\n\t\t\t} else {\n\n\t\t\t\t_face.getNormal( targetNormal );\n\n\t\t\t}\n\n\t\t}\n\n\t\tif ( targetColor !== undefined && this.colorAttribute !== undefined ) {\n\n\t\t\t_face.a.fromBufferAttribute( this.colorAttribute, i0 );\n\t\t\t_face.b.fromBufferAttribute( this.colorAttribute, i1 );\n\t\t\t_face.c.fromBufferAttribute( this.colorAttribute, i2 );\n\n\t\t\t_color\n\t\t\t\t.set( 0, 0, 0 )\n\t\t\t\t.addScaledVector( _face.a, u )\n\t\t\t\t.addScaledVector( _face.b, v )\n\t\t\t\t.addScaledVector( _face.c, 1 - ( u + v ) );\n\n\t\t\ttargetColor.r = _color.x;\n\t\t\ttargetColor.g = _color.y;\n\t\t\ttargetColor.b = _color.z;\n\n\t\t}\n\n\t\tif ( targetUV !== undefined && this.uvAttribute !== undefined ) {\n\n\t\t\t_uva.fromBufferAttribute( this.uvAttribute, i0 );\n\t\t\t_uvb.fromBufferAttribute( this.uvAttribute, i1 );\n\t\t\t_uvc.fromBufferAttribute( this.uvAttribute, i2 );\n\t\t\ttargetUV.set( 0, 0 ).addScaledVector( _uva, u ).addScaledVector( _uvb, v ).addScaledVector( _uvc, 1 - ( u + v ) );\n\n\t\t}\n\n\t\treturn this;\n\n\t}\n\n}\n\nexport { MeshSurfaceSampler };\n","import * as THREE from \"three\";\nimport { OBJLoader } from \"three/examples/jsm/loaders/OBJLoader.js\";\nimport { MeshSurfaceSampler } from \"three/examples/jsm/math/MeshSurfaceSampler.js\";\nimport { gsap } from \"gsap\";\n\ninterface ParticleSettings {\n  particleCount: number;\n  particleSize: number;\n  animationSpeed: number;\n  autoRotate: boolean;\n  morphDuration: number;\n  currentColor: THREE.Color;\n}\n\nclass ParticleMorpher {\n  private container: HTMLCanvasElement;\n  private scene: THREE.Scene;\n  private camera: THREE.PerspectiveCamera;\n  private renderer: THREE.WebGLRenderer;\n  private settings: ParticleSettings;\n  private particles: THREE.Points | null = null;\n  private readonly models: { [key: string]: Float32Array } = {};\n  private currentShape: string = \"queen\";\n  private isTransitioning: boolean = false;\n  private loader: OBJLoader;\n  private lastTime: number = 0;\n\n  constructor() {\n    const canvas = document.getElementById(\"canvas\") as HTMLCanvasElement;\n    if (!canvas) throw new Error(\"Canvas element not found\");\n    this.container = canvas;\n\n    this.scene = new THREE.Scene();\n    this.scene.background = new THREE.Color(0x030012);\n\n    this.camera = new THREE.PerspectiveCamera(\n      45,\n      window.innerWidth / window.innerHeight,\n      0.1,\n      1000\n    );\n    this.camera.position.set(0, 10, 50);\n    this.camera.lookAt(0, 0, 0);\n\n    this.renderer = new THREE.WebGLRenderer({\n      canvas: this.container,\n      antialias: true,\n      alpha: true,\n    });\n    this.renderer.setPixelRatio(Math.min(window.devicePixelRatio, 2));\n    this.renderer.setSize(window.innerWidth, window.innerHeight);\n\n    // Settings\n    this.settings = {\n      particleCount: 15000,\n      particleSize: 1.2,\n      animationSpeed: 1,\n      autoRotate: true,\n      morphDuration: 2.5,\n      currentColor: new THREE.Color(0x088cff),\n    };\n\n    this.loader = new OBJLoader();\n    this.init();\n  }\n\n  private async init() {\n    this.setupParticles();\n    this.setupEvents();\n    this.setupUI();\n\n    await this.loadModels();\n    this.hideLoader();\n\n    this.morphTo(\"queen\");\n    this.animate();\n  }\n\n  private setupParticles() {\n    const geometry = new THREE.BufferGeometry();\n    const positions = new Float32Array(this.settings.particleCount * 3);\n\n    // Random initial positions\n    for (let i = 0; i < this.settings.particleCount; i++) {\n      positions[i * 3] = (Math.random() - 0.5) * 500;\n      positions[i * 3 + 1] = (Math.random() - 0.5) * 500;\n      positions[i * 3 + 2] = (Math.random() - 0.5) * 500;\n    }\n\n    geometry.setAttribute(\"position\", new THREE.BufferAttribute(positions, 3));\n\n    const material = new THREE.PointsMaterial({\n      color: this.settings.currentColor,\n      size: this.settings.particleSize,\n      sizeAttenuation: false,\n      transparent: true,\n      opacity: 0.8,\n      blending: THREE.AdditiveBlending,\n    });\n\n    this.particles = new THREE.Points(geometry, material);\n    this.scene.add(this.particles);\n  }\n\n  private async loadModels() {\n    const loadModel = (name: string, path: string, scale: number) => {\n      return new Promise<void>((resolve) => {\n        this.loader.load(\n          path,\n          (obj) => {\n            let mesh: THREE.Mesh | null = null;\n            obj.traverse((child) => {\n              if ((child as THREE.Mesh).isMesh) {\n                const m = child as THREE.Mesh;\n                m.geometry.scale(scale, scale, scale);\n                m.geometry.center();\n                mesh = m;\n              }\n            });\n\n            if (mesh) {\n              const points = this.samplePointsOnSurface(\n                mesh,\n                this.settings.particleCount\n              );\n              this.models[name] = points;\n            }\n            resolve();\n          },\n          (xhr) => {\n            if (xhr.total > 0) {\n              const percent = (xhr.loaded / xhr.total) * 100;\n              const progressBar = document.getElementById(\"progress-bar\");\n              if (progressBar) progressBar.style.width = `${percent}%`;\n            }\n          }\n        );\n      });\n    };\n\n    await Promise.all([\n      loadModel(\"queen\", \"models/Queen.obj\", 200),\n      loadModel(\"pawn\", \"models/Pawn.obj\", 250),\n    ]);\n  }\n\n  private samplePointsOnSurface(mesh: THREE.Mesh, count: number): Float32Array {\n    const sampler = new MeshSurfaceSampler(mesh).build();\n    const sampledPositions = new Float32Array(count * 3);\n    const tempPosition = new THREE.Vector3();\n\n    for (let i = 0; i < count; i++) {\n      sampler.sample(tempPosition);\n      sampledPositions[i * 3] = tempPosition.x;\n      sampledPositions[i * 3 + 1] = tempPosition.y;\n      sampledPositions[i * 3 + 2] = tempPosition.z;\n    }\n\n    return sampledPositions;\n  }\n\n  public morphTo(shape: string) {\n    if (this.isTransitioning && shape !== \"explode\") return;\n    if (!this.particles) return;\n    this.isTransitioning = true;\n\n    const targetPositions =\n      shape === \"explode\" ? this.getExplodePositions() : this.models[shape];\n\n    if (!targetPositions) {\n      this.isTransitioning = false;\n      return;\n    }\n\n    const currentPositions = this.particles.geometry.attributes.position\n      .array as Float32Array;\n\n    gsap.to(currentPositions, {\n      duration: this.settings.morphDuration / this.settings.animationSpeed,\n      endArray: targetPositions as any,\n      ease: \"expo.inOut\",\n      onUpdate: () => {\n        if (this.particles)\n          this.particles.geometry.attributes.position.needsUpdate = true;\n      },\n      onComplete: () => {\n        this.isTransitioning = false;\n        this.currentShape = shape;\n        console.log(`Morphed to: ${this.currentShape}`);\n      },\n    });\n\n    // Update UI active state\n    document.querySelectorAll(\".shape-btn\").forEach((btn) => {\n      (btn as HTMLElement).classList.toggle(\n        \"active\",\n        (btn as HTMLElement).dataset.shape === shape\n      );\n    });\n  }\n\n  private getExplodePositions(): Float32Array {\n    const positions = new Float32Array(this.settings.particleCount * 3);\n    for (let i = 0; i < this.settings.particleCount; i++) {\n      positions[i * 3] = (Math.random() - 0.5) * 500;\n      positions[i * 3 + 1] = (Math.random() - 0.5) * 500;\n      positions[i * 3 + 2] = (Math.random() - 0.5) * 500;\n    }\n    return positions;\n  }\n\n  private setColor(colorHex: string) {\n    if (!this.particles) return;\n    const color = new THREE.Color(colorHex);\n    gsap.to((this.particles.material as THREE.PointsMaterial).color, {\n      duration: 1,\n      r: color.r,\n      g: color.g,\n      b: color.b,\n      ease: \"power2.out\",\n    });\n    this.settings.currentColor = color;\n  }\n\n  private setupEvents() {\n    window.addEventListener(\"resize\", () => {\n      this.camera.aspect = window.innerWidth / window.innerHeight;\n      this.camera.updateProjectionMatrix();\n      this.renderer.setSize(window.innerWidth, window.innerHeight);\n    });\n\n    // Info toggle\n    const infoPanel = document.getElementById(\"info-panel\");\n    const infoToggle = document.getElementById(\"info-toggle\");\n    if (infoPanel && infoToggle) {\n      infoToggle.addEventListener(\"click\", () => {\n        infoPanel.classList.toggle(\"open\");\n      });\n    }\n  }\n\n  private setupUI() {\n    // Shape Buttons\n    const queenBtn = document.getElementById(\"btn-queen\");\n    const pawnBtn = document.getElementById(\"btn-pawn\");\n    const explodeBtn = document.getElementById(\"btn-explode\");\n\n    if (queenBtn)\n      queenBtn.addEventListener(\"click\", () => this.morphTo(\"queen\"));\n    if (pawnBtn) pawnBtn.addEventListener(\"click\", () => this.morphTo(\"pawn\"));\n    if (explodeBtn)\n      explodeBtn.addEventListener(\"click\", () => this.morphTo(\"explode\"));\n\n    // Speed Slider\n    const speedSlider = document.getElementById(\n      \"speed-slider\"\n    ) as HTMLInputElement;\n    const speedValue = document.getElementById(\"speed-value\");\n    if (speedSlider) {\n      speedSlider.addEventListener(\"input\", (e) => {\n        const val = parseFloat((e.target as HTMLInputElement).value);\n        this.settings.animationSpeed = val;\n        if (speedValue) speedValue.textContent = `${val.toFixed(1)}x`;\n      });\n    }\n\n    // Size Slider\n    const sizeSlider = document.getElementById(\n      \"particle-size-slider\"\n    ) as HTMLInputElement;\n    const sizeValue = document.getElementById(\"size-value\");\n    if (sizeSlider) {\n      sizeSlider.addEventListener(\"input\", (e) => {\n        const val = parseFloat((e.target as HTMLInputElement).value);\n        this.settings.particleSize = val;\n        if (this.particles)\n          (this.particles.material as THREE.PointsMaterial).size = val;\n        if (sizeValue) sizeValue.textContent = val.toFixed(1);\n      });\n    }\n\n    // Color buttons\n    document.querySelectorAll(\".color-btn\").forEach((btn) => {\n      btn.addEventListener(\"click\", () => {\n        document\n          .querySelectorAll(\".color-btn\")\n          .forEach((b) => b.classList.remove(\"active\"));\n        (btn as HTMLElement).classList.add(\"active\");\n        const color = (btn as HTMLElement).dataset.color;\n        if (color) this.setColor(color);\n      });\n    });\n\n    // Auto Rotate\n    const autoRotateCheck = document.getElementById(\n      \"auto-rotate\"\n    ) as HTMLInputElement;\n    if (autoRotateCheck) {\n      autoRotateCheck.addEventListener(\"change\", (e) => {\n        this.settings.autoRotate = (e.target as HTMLInputElement).checked;\n      });\n    }\n\n    // Fullscreen\n    const fullscreenBtn = document.getElementById(\"fullscreen-btn\");\n    if (fullscreenBtn) {\n      fullscreenBtn.addEventListener(\"click\", (e) => {\n        e.preventDefault();\n        if (!document.fullscreenElement) {\n          document.documentElement.requestFullscreen();\n          (e.target as HTMLElement).textContent = \"Exit Fullscreen\";\n        } else {\n          document.exitFullscreen();\n          (e.target as HTMLElement).textContent = \"Fullscreen\";\n        }\n      });\n    }\n  }\n\n  private hideLoader() {\n    const loader = document.getElementById(\"loader\");\n    if (loader) {\n      loader.classList.add(\"hidden\");\n      setTimeout(() => (loader.style.display = \"none\"), 800);\n    }\n  }\n\n  private animate() {\n    requestAnimationFrame(() => this.animate());\n\n    if (this.settings.autoRotate && this.particles) {\n      this.particles.rotation.y += 0.005 * this.settings.animationSpeed;\n    }\n\n    this.updateStats();\n    this.renderer.render(this.scene, this.camera);\n  }\n\n  private updateStats() {\n    // Simple FPS counter\n    if (!this.lastTime) this.lastTime = performance.now();\n    const now = performance.now();\n    const delta = now - this.lastTime;\n    this.lastTime = now;\n\n    if (Math.random() > 0.9) {\n      // Update text occasionally\n      const fps = Math.round(1000 / delta);\n      const fpsCounter = document.getElementById(\"fps-counter\");\n      if (fpsCounter) fpsCounter.textContent = fps.toString();\n    }\n  }\n}\n\n// Start the app\nnew ParticleMorpher();\n"],"names":["_object_pattern","_material_library_pattern","_material_use_pattern","_map_use_pattern","_face_vertex_data_separator_pattern","_vA","Vector3","_vB","_vC","_ab","_cb","_color","Color","ParserState","state","objects","object","vertices","normals","colors","uvs","materials","materialLibraries","startObject","name","fromDeclaration","this","previousMaterial","currentMaterial","_finalize","geometry","hasUVIndices","smooth","startMaterial","libraries","previous","inherited","groupCount","splice","index","material","length","mtllib","Array","isArray","groupStart","groupEnd","clone","cloned","bind","push","end","lastMultiMaterial","mi","declared","finalize","parseVertexIndex","value","len","parseInt","parseNormalIndex","parseUVIndex","addVertex","a","b","c","src","dst","addVertexPoint","addVertexLine","addNormal","addFaceNormal","fromArray","subVectors","cross","normalize","x","y","z","addColor","addUV","addDefaultUV","addUVLine","addFace","ua","ub","uc","na","nb","nc","vLen","ia","ib","ic","nLen","uvLen","addPointGeometry","type","vi","l","addLineGeometry","uvi","OBJLoader","Loader","constructor","manager","super","load","url","onLoad","onProgress","onError","scope","loader","FileLoader","setPath","path","setRequestHeader","requestHeader","setWithCredentials","withCredentials","text","parse","e","itemError","setMaterials","indexOf","replace","lines","split","result","i","line","trimStart","lineFirstChar","charAt","data","parseFloat","setRGB","convertSRGBToLinear","r","g","vertexData","slice","trim","faceVertices","j","jl","vertex","vertexParts","v1","v2","v3","lineParts","substring","lineVertices","lineUVs","li","llen","parts","pointData","exec","test","toLowerCase","container","Group","concat","isLine","isPoints","hasVertexColors","buffergeometry","BufferGeometry","setAttribute","Float32BufferAttribute","createdMaterials","miLen","sourceMaterial","materialHash","create","LineBasicMaterial","PointsMaterial","materialPoints","size","sizeAttenuation","Material","prototype","copy","call","color","map","materialLine","MeshPhongMaterial","flatShading","vertexColors","mesh","addGroup","LineSegments","Points","Mesh","add","points","_face","Triangle","_uva","Vector2","_uvb","_uvc","MeshSurfaceSampler","randomFunction","Math","random","indexAttribute","positionAttribute","getAttribute","normalAttribute","colorAttribute","uvAttribute","weightAttribute","distribution","setWeightAttribute","build","totalFaces","count","faceWeights","Float32Array","faceWeight","i0","i1","i2","getX","fromBufferAttribute","getArea","cumulativeTotal","setRandomGenerator","sample","targetPosition","targetNormal","targetColor","targetUV","faceIndex","sampleFaceIndex","sampleFace","binarySearch","dist","start","mid","ceil","u","v","set","addScaledVector","getNormal","__publicField","canvas","document","getElementById","Error","scene","THREE.Scene","background","THREE.Color","camera","THREE.PerspectiveCamera","window","innerWidth","innerHeight","position","lookAt","renderer","THREE.WebGLRenderer","antialias","alpha","setPixelRatio","min","devicePixelRatio","setSize","settings","particleCount","particleSize","animationSpeed","autoRotate","morphDuration","currentColor","init","setupParticles","setupEvents","setupUI","loadModels","hideLoader","morphTo","animate","THREE.BufferGeometry","positions","THREE.BufferAttribute","THREE.PointsMaterial","transparent","opacity","blending","THREE.AdditiveBlending","particles","THREE.Points","loadModel","scale","Promise","resolve","obj","traverse","child","isMesh","m","center","samplePointsOnSurface","models","xhr","total","percent","loaded","progressBar","style","width","all","sampler","sampledPositions","tempPosition","THREE.Vector3","shape","isTransitioning","targetPositions","getExplodePositions","currentPositions","attributes","array","gsap","to","duration","endArray","ease","onUpdate","needsUpdate","onComplete","currentShape","querySelectorAll","forEach","btn","classList","toggle","dataset","setColor","colorHex","addEventListener","aspect","updateProjectionMatrix","infoPanel","infoToggle","queenBtn","pawnBtn","explodeBtn","speedSlider","speedValue","val","target","textContent","toFixed","sizeSlider","sizeValue","remove","autoRotateCheck","checked","fullscreenBtn","preventDefault","fullscreenElement","exitFullscreen","documentElement","requestFullscreen","setTimeout","display","requestAnimationFrame","rotation","updateStats","render","lastTime","performance","now","delta","fps","round","fpsCounter","toString"],"mappings":"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","x_google_ignoreList":[0,1]}